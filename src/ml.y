/**
 * @file calc.y
 * @brief This file is part of the clc distribution.
 * Copyright (c) 2026 blu3
 *
 * A fixed and completed parser with an interpreter for a simple functional
 * language. This file (calc.y) defines the grammar for a small functional
 * language using Bison and defines an interpreter which evaluates the Abstract
 * Syntax Tree (AST) generated by Flex from the file (calc.l)
 **/

/**************************************************************************\
 *                                                                        *
 *  This program is free software: you can redistribute it and/or modify  *
 *  it under the terms of the GNU General Public License as published by  *
 *  the Free Software Foundation, version 3.                              *
 *                                                                        *
 *  This program is distributed in the hope that it will be useful, but   *
 *  WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU      *
 *  General Public License for more details.                              *
 *                                                                        *
 *  You should have received a copy of the GNU General Public License     *
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.  *
 *                                                                        *
\**************************************************************************/

/* BISON PREAMBLE
 * C code to be included in the generated parser.
 */

%{
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <math.h> /* For fmod in future, or other math functions */

/* Custom header files for data structures. */
#include "ml.h" // Defines ASTNode, Value, etc.
#include "env.h"  /* Defines the environment for variable storage. */

/* Forward declarations of helper functions defined in the C section below. */
ASTNode *make_node(NodeType t);
Value *make_int(int x);
Value *make_float(double x);
Value *make_bool(bool b);
Value *make_unit();
Value *make_string(const char *s);
Value *make_func(Function *f);

/* The core interpreter function. */
Value *eval(ASTNode *node, Env *env);

/* Memory management functions. */
void free_value(Value *v);
void free_ast(ASTNode *node);
void yylex_destroy();

/* Global environment to store top-level bindings. */
static Env *global_env = NULL;

/* --- String Macros for Output and Errors --- */

/* Display strings for different value types. */
#define STR_SHOW_TRUE   "true"
#define STR_SHOW_FALSE  "false"
#define STR_SHOW_INT    "=> %d\n"
#define STR_SHOW_FLOAT  "=> %.6g\n"
#define STR_SHOW_BOOL   "=> %s\n"
#define STR_SHOW_STRING "=> \"%s\"\n"
#define STR_SHOW_FUNC   "=> <function>\n"
#define STR_SHOW_UNIT   "\n" /* Unit type prints nothing. */

/* Error message strings. */
#define STR_ERR_NON_BOOL_NOT      "Line %d: Error: NOT requires a boolean operand\n"
#define STR_ERR_IF_NON_BOOL       "Line %d: Error: IF condition must be a boolean\n"
#define STR_NON_FUN_CALL          "Line %d: Error: Attempted to call a non-function value\n"
#define STR_BIN_OP_TYPE_ERR       "Line %d: Error: Type mismatch in binary operation\n"
#define STR_ERR_UNKNOWN_AST_TYPE  "Line %d: Error: Unknown AST node type\n"
#define STR_ERR_MALLOC_CONC       "Fatal: malloc failed in string concat\n"
#define STR_ERR_DIV_ZERO          "Line %d: Error: Division by zero\n"
#define STR_ERR_MOD_ZERO          "Line %d: Error: Modulo by zero\n"
#define STR_UNARY_MINUS           "Line %d: Error: Unary minus requires a numeric operand\n"
#define STR_CALLOC_FAIL           "Line %d: Fatal, calloc failed in make_node\n"
#define STR_PARSE_ERR             "Line %d: Parse error: %s\n"

/* General strings. */
#define STR_GOODBYE             "Goodbye!\n"
#define STR_FILE_LOAD_ERROR     "Error loading file %s"
#define BANNER                  "Type 'quit' or 'exit' to leave.\n\n"

%}

/*
 * Bison union to hold the different types of semantic values that can be
 * associated with tokens and non-terminal symbols in the grammar.
 */
%union {
    char *id;
    int ival;
    double fval;
    char *sval;
    char *name;
    struct Value *value;
    struct ASTNode *node;
    struct ExprList *elist;
}

/* --- Token Declarations --- */
/* Associates tokens with a type from the %union if they carry a value. */
%token<id> T_ID
%token<ival> T_INT
%token<fval> T_FLOAT
%token<sval> T_STR
%token<name> T_SYM T_NAME

/* Keyword and Operator Tokens (no associated value needed) */
%token T_PLUS T_MINUS T_MULTIPLY T_DIVIDE T_MOD
%token T_LEFT T_RIGHT T_BLEFT T_BRIGHT /* ( ) { } */
%token T_TRUE T_FALSE
%token T_IF T_THEN T_ELSE
%token T_LET T_IN T_SET
%token T_FUN T_ARROW T_TYPE T_COLON
%token T_AND T_OR T_NOT
%token T_EQ T_NEQ T_LT T_GT T_LTE T_GTE
%token T_CONST T_DO T_END
%token T_SEMICOLON T_COMMA
%token T_NEWLINE T_QUIT
%token T_LAMBDA

/* --- Operator Precedence and Associativity (from lowest to highest) --- */
%right T_SET                      /* Assignment */
%left  T_OR                       /* Logical OR */
%left  T_AND                      /* Logical AND */
%nonassoc T_EQ T_NEQ T_LT T_GT T_LTE T_GTE /* Comparison ops (non-associative) */
%left  T_PLUS T_MINUS             /* Addition, Subtraction */
%left  T_MULTIPLY T_DIVIDE T_MOD  /* Multiplication, Division, Modulo */
%right T_NOT UMINUS               /* Logical NOT, Unary Minus (highest precedence unary) */
%left  T_LEFT                     /* Function application has high precedence */

/* --- Type Declarations for Non-terminals --- */
/* Associates non-terminal grammar rules with a type from the %union. */
%type<node> program statement expr primary term factor
%type<node> if_expr let_expr lambda_expr block_expr
%type<node> assignment const_def
%type<name> opt_ret_type
%type<elist> stmt_list expr_seq

/* --- Destructors for Memory Management --- */
/*
 * These rules tell Bison how to free memory for a symbol if a syntax error
 * occurs and the symbol is discarded during error recovery.
 */
%destructor { free($$); } T_STR T_SYM T_NAME T_ID
%destructor { free_ast($$); } <node>

/* The starting rule for the grammar. */
%start program

%%

/*
 * ============================================================================
 * GRAMMAR RULES
 * ============================================================================
 * The following section defines the syntax of the language. Each rule
 * specifies how to recognize a language construct and the C code in { ... }
 * (the "action") describes what to do when the rule is matched, typically
 * building a piece of the Abstract Syntax Tree (AST).
 * ============================================================================
 */

/*
 * The top-level rule. A program is a sequence of statements.
 * This rule also acts as the Read-Eval-Print-Loop (REPL).
 */
program:
    /* An empty program is valid. */
    /* empty */           { $$ = NULL; }

    /* A program is a program followed by a statement. */
    | program statement   {
        /* If the statement produced an AST ($2 is not NULL)... */
        if ($2) {
            /* Evaluate the AST in the global environment. */
            Value *v = eval($2, global_env);

            /* If evaluation produced a result... */
            if (v) {
                /* Print the result based on its type. */
                switch(v->type) {
                    case VAL_INT:    printf(STR_SHOW_INT, v->ival); break;
                    case VAL_FLOAT:  printf(STR_SHOW_FLOAT, v->fval); break;
                    case VAL_BOOL:
                        printf(STR_SHOW_BOOL,
                               v->bval ? STR_SHOW_TRUE : STR_SHOW_FALSE);
                        break;
                    case VAL_STRING: printf(STR_SHOW_STRING, v->sval); break;
                    case VAL_FUNC:   printf(STR_SHOW_FUNC); break;
                    case VAL_UNIT:   /* Print nothing for unit type */ break;
                }
                /* Free the resulting value from the evaluation. */
                free_value(v);
            }
            /* Free the AST for the statement now that we're done with it. */
            free_ast($2);
        }
    }
;

/*
 * A statement can be an expression, an assignment, a definition,
 * or a command, terminated by a newline or semicolon.
 */
statement:
    T_NEWLINE             { $$ = NULL; } /* An empty line is a valid statement. */
    | expr T_NEWLINE      { $$ = $1; }   /* An expression followed by a newline. */
    | expr T_SEMICOLON    { $$ = $1; }   /* An expression followed by a semicolon. */
    | assignment T_NEWLINE { $$ = $1; }
    | const_def T_NEWLINE  { $$ = $1; }
    | T_QUIT T_NEWLINE    {
        printf(STR_GOODBYE);
        free_env(global_env, true); /* Free the global environment. */
        yylex_destroy();            /* Clean up the lexer. */
        exit(0);
    }
;

/*
 * An expression. This part of the grammar defines operator precedence
 * for binary logical and comparison operators.
 */
expr:
    term
    | if_expr
    | let_expr
    | lambda_expr
    | block_expr
    /* Binary operations */
    | expr T_OR term        { $$ = make_node(NODE_BINOP); $$->binop.left=$1; $$->binop.right=$3; $$->binop.op=T_OR; }
    | expr T_AND term       { $$ = make_node(NODE_BINOP); $$->binop.left=$1; $$->binop.right=$3; $$->binop.op=T_AND; }
    | expr T_EQ term        { $$ = make_node(NODE_BINOP); $$->binop.left=$1; $$->binop.right=$3; $$->binop.op=T_EQ; }
    | expr T_NEQ term       { $$ = make_node(NODE_BINOP); $$->binop.left=$1; $$->binop.right=$3; $$->binop.op=T_NEQ; }
    | expr T_LT term        { $$ = make_node(NODE_BINOP); $$->binop.left=$1; $$->binop.right=$3; $$->binop.op=T_LT; }
    | expr T_GT term        { $$ = make_node(NODE_BINOP); $$->binop.left=$1; $$->binop.right=$3; $$->binop.op=T_GT; }
    | expr T_LTE term       { $$ = make_node(NODE_BINOP); $$->binop.left=$1; $$->binop.right=$3; $$->binop.op=T_LTE; }
    | expr T_GTE term       { $$ = make_node(NODE_BINOP); $$->binop.left=$1; $$->binop.right=$3; $$->binop.op=T_GTE; }
    | expr T_PLUS term      { $$ = make_node(NODE_BINOP); $$->binop.left=$1; $$->binop.right=$3; $$->binop.op=T_PLUS; }
    | expr T_MINUS term     { $$ = make_node(NODE_BINOP); $$->binop.left=$1; $$->binop.right=$3; $$->binop.op=T_MINUS; }
;

/*
 * A term. Handles multiplicative operators (*, /, %).
 */
term:
    factor
    | term T_MULTIPLY factor { $$ = make_node(NODE_BINOP); $$->binop.left=$1; $$->binop.right=$3; $$->binop.op=T_MULTIPLY; }
    | term T_DIVIDE factor   { $$ = make_node(NODE_BINOP); $$->binop.left=$1; $$->binop.right=$3; $$->binop.op=T_DIVIDE; }
    | term T_MOD factor      { $$ = make_node(NODE_BINOP); $$->binop.left=$1; $$->binop.right=$3; $$->binop.op=T_MOD; }
;

/*
 * A factor. Handles unary operators and function calls.
 */
factor:
    primary
    | T_NOT factor           { $$ = make_node(NODE_UNOP); $$->unop.operand=$2; $$->unop.op=T_NOT; }
    /* %prec UMINUS resolves the shift/reduce conflict for the minus sign. */
    | T_MINUS factor %prec UMINUS { $$ = make_node(NODE_UNOP); $$->unop.operand=$2; $$->unop.op=T_MINUS; }
    /* Function application: e.g., f(x) */
    | factor T_LEFT expr T_RIGHT {
        $$ = make_node(NODE_CALL);
        $$->call.fn = $1;
        $$->call.arg = $3;
    }
;

/*
 * The most basic building blocks of an expression.
 */
primary:
    T_INT                   { $$ = make_node(NODE_VAL); $$->val = make_int($1); }
    | T_FLOAT               { $$ = make_node(NODE_VAL); $$->val = make_float($1); }
    | T_TRUE                { $$ = make_node(NODE_VAL); $$->val = make_bool(true); }
    | T_FALSE               { $$ = make_node(NODE_VAL); $$->val = make_bool(false); }
    | T_STR                 { $$ = make_node(NODE_VAL); $$->val = make_string($1); free($1); }
    | T_SYM                 { $$ = make_node(NODE_VAR); $$->var = $1; }
    | T_LEFT expr T_RIGHT   { $$ = $2; } /* Parenthesized expression. */
;


maybe_newline:
                T_NEWLINE
        |       /* empty */
;
/*
 * An if-then-else expression.
 */
if_expr:
    T_IF expr maybe_newline T_THEN expr maybe_newline  T_ELSE expr {
        $$ = make_node(NODE_IF);
        $$->ifexpr.cond = $2;
        $$->ifexpr.then_expr = $5;
        $$->ifexpr.else_expr = $8;
    }
;

/*
 * A let expression for local bindings. `let x = 5 in x * 2`
 */
let_expr:

    T_LET T_SYM T_SET expr maybe_newline T_IN  expr {
        $$ = make_node(NODE_LET);
        $$->let.name = $2;
        $$->let.value = $4;
        $$->let.body = $7;
    }
;


/*
 * A lambda (anonymous function) expression. `lambda x -> x + 1`
 */
lambda_expr:
    T_LAMBDA T_SYM maybe_newline T_ARROW maybe_newline expr {
        $$ = make_node(NODE_LAMBDA);
        $$->lambda.param = $2;
        $$->lambda.param_type = NULL; /* Type annotations are optional */
        $$->lambda.ret_type = NULL;
        $$->lambda.body = $6;
    }
;

/* Rule for an optional return type annotation. Currently unused in lambda_expr. */
opt_ret_type:
    /* empty */       { $$ = NULL; }
    | maybe_newline T_COLON T_SYM   { $$ = $3; }
;

/* A block of expressions, like `do ... end` or `{ ... }`. */
block_expr:
    T_DO stmt_list T_END {
        $$ = make_node(NODE_SEQ);
        $$->seq.elist = $2;
    }
    | T_BLEFT expr_seq T_BRIGHT {
        $$ = make_node(NODE_SEQ);
        $$->seq.elist = $2;
    }
;

/* An assignment statement. `x = 10` */
assignment:
    T_SYM T_SET expr {
        $$ = make_node(NODE_ASSIGN);
        $$->assign.name = $1;
        $$->assign.value = $3;
    }
;

/* A constant definition. `const pi = 3.14` */
const_def:
    /* With optional type annotation */
    T_CONST T_SYM T_COLON T_SYM T_SET expr {
        $$ = make_node(NODE_CONST);
        $$->cdef.name = $2;
        $$->cdef.type_name = $4;
        $$->cdef.value = $6;
    }
    /* Without type annotation */
    | T_CONST T_SYM T_SET expr {
        $$ = make_node(NODE_CONST);
        $$->cdef.name = $2;
        $$->cdef.type_name = NULL;
        $$->cdef.value = $4;
    }
;

/* A list of statements for a 'do...end' block. */
stmt_list:
    expr T_SEMICOLON {
        ExprList *e = malloc(sizeof(ExprList));
        e->expr = $1; e->next = NULL; $$ = e;
    }
    | expr T_SEMICOLON stmt_list {
        ExprList *e = malloc(sizeof(ExprList));
        e->expr = $1; e->next = $3; $$ = e;
    }
;

/* A sequence of expressions for a '{...}' block. */
expr_seq:
    expr {
        ExprList *e = malloc(sizeof(ExprList));
        e->expr = $1; e->next = NULL; $$ = e;
    }
    | expr T_COMMA expr_seq {
        ExprList *e = malloc(sizeof(ExprList));
        e->expr = $1; e->next = $3; $$ = e;
    }
;

%%

/*
 * ============================================================================
 * C CODE SECTION
 * ============================================================================
 * This section contains the implementation of the interpreter, helper
 * functions for building the AST and Values, and memory management routines.
 * ============================================================================
 */


/*
 * ----------------------------------------------------------------------------
 * HELPER FUNCTIONS
 * ----------------------------------------------------------------------------
 */

/**
 * @brief Creates a new ASTNode of a given type.
 * @param t The NodeType for the new node.
 * @return A pointer to the newly allocated and initialized ASTNode.
 */
ASTNode *make_node(NodeType t)
{
    ASTNode *n = calloc(1, sizeof(ASTNode));
    if (!n) {
        fprintf(stderr, STR_CALLOC_FAIL, yylineno);
        exit(EXIT_FAILURE);
    }
    n->type = t;
    n->lineno = yylineno; // Store the line number for error reporting.
    return n;
}


/*
 * ----------------------------------------------------------------------------
 * VALUE CONSTRUCTORS
 * ----------------------------------------------------------------------------
 * These functions create `Value` structs for the interpreter. They handle
 * memory allocation and initialization for different data types.
 */

Value *make_int(int x) {
    Value *v = malloc(sizeof(Value));
    v->type = VAL_INT;
    v->ival = x;
    return v;
}

Value *make_float(double x) {
    Value *v = malloc(sizeof(Value));
    v->type = VAL_FLOAT;
    v->fval = x;
    return v;
}

Value *make_bool(bool b) {
    Value *v = malloc(sizeof(Value));
    v->type = VAL_BOOL;
    v->bval = b;
    return v;
}

Value *make_unit() {
    Value *v = malloc(sizeof(Value));
    v->type = VAL_UNIT;
    return v;
}

Value *make_string(const char *s) {
    Value *v = malloc(sizeof(Value));
    v->type = VAL_STRING;
    v->sval = strdup(s); /* Use strdup for safety. */
    return v;
}

Value *make_func(Function *f) {
    Value *v = malloc(sizeof(Value));
    v->type = VAL_FUNC;
    v->func = f;
    return v;
}

/*
 * ----------------------------------------------------------------------------
 * INTERPRETER / EVALUATOR
 * ----------------------------------------------------------------------------
 */

/* Forward declaration for the binary operation helper. */
Value *eval_binop(ASTNode *node, Env *env, Value *l, Value *r);

/**
 * @brief Recursively evaluates an ASTNode in a given environment.
 *
 * This function is the core of the interpreter. It traverses the AST
 * post-order and computes a `Value` for each node.
 *
 * @param node The ASTNode to evaluate.
 * @param env The environment (scope) in which to evaluate the node.
 * @return A pointer to a new `Value` struct representing the result.
 * The caller is responsible for freeing this value.
 */
Value *eval(ASTNode *node, Env *env) {
    if (!node) return make_unit();

    switch(node->type) {
        case NODE_VAL:
            /* A value node simply returns a copy of its stored value. */
            return dup_value(node->val);

        case NODE_VAR:
            /* Look up the variable's value in the current environment. */
            return env_get(env, node->var);

        case NODE_UNOP: {
            Value *v = eval(node->unop.operand, env);
            if (!v) return make_unit();

            Value *retval = NULL;
            if (node->unop.op == T_NOT) {
                if (v->type == VAL_BOOL) {
                    retval = make_bool(!v->bval);
                } else {
                    fprintf(stderr, STR_ERR_NON_BOOL_NOT, node->lineno);
                    retval = make_unit();
                }
            } else if (node->unop.op == T_MINUS) { /* Unary minus */
                if (v->type == VAL_INT) {
                    retval = make_int(-v->ival);
                } else if (v->type == VAL_FLOAT) {
                    retval = make_float(-v->fval);
                } else {
                    fprintf(stderr, STR_UNARY_MINUS, node->lineno);
                    retval = make_unit();
                }
            }
            free_value(v);
            return retval;
        }

        case NODE_BINOP: {
            Value *l = eval(node->binop.left, env);
            Value *r = eval(node->binop.right, env);
            Value *res = eval_binop(node, env, l, r);
            free_value(l);
            free_value(r);
            return res;
        }

        case NODE_IF: {
            Value *c = eval(node->ifexpr.cond, env);
            if (!c) return make_unit();

            if (c->type != VAL_BOOL) {
                fprintf(stderr, STR_ERR_IF_NON_BOOL, node->lineno);
                free_value(c);
                return make_unit();
            }

            bool is_true = c->bval;
            free_value(c);

            /* Evaluate either the 'then' or 'else' branch. */
            return eval(is_true ? node->ifexpr.then_expr : node->ifexpr.else_expr, env);
        }

        case NODE_LET: {
            /* Evaluate the value to be bound. */
            Value *v = eval(node->let.value, env);
            if (!v) return make_unit();

            /* Create a new, nested environment. */
            Env *local = new_env(env);
            env_set(local, node->let.name, v, false); /* Add the new binding. */

            /* Evaluate the body of the 'let' in the new environment. */
            Value *retval = eval(node->let.body, local);

            /* The local environment now owns 'v', so we don't free 'v' here. */
            env_release(local);
            return retval;
        }

        case NODE_ASSIGN: {
            Value *v = eval(node->assign.value, env);
            if (!v) return make_unit();

            /* Update the variable in the environment. */
            env_update(env, node->assign.name, v);
            /* Assignment expression evaluates to the assigned value. */
            return dup_value(v);
        }

        case NODE_CONST: {
            Value *val = eval(node->cdef.value, env);
            if (!val) return make_unit();

            env_set(env, node->cdef.name, val, true); /* Set as constant. */
            return dup_value(val);
        }

        case NODE_LAMBDA: {
            Env *local = new_env(env);

            /* Create a function closure. */
            Function *f = malloc(sizeof(Function));
            f->param = strdup(node->lambda.param);
            f->param_type = node->lambda.param_type ? strdup(node->lambda.param_type) : NULL;
            f->ret_type = node->lambda.ret_type ? strdup(node->lambda.ret_type) : NULL;
            f->body = node->lambda.body;
            /* IMPORTANT: Capture the current environment. This is the closure. */
            f->env = local;
            return make_func(f);
        }

        case NODE_CALL: {
            /* Evaluate the function expression itself. */
            Value *fn_val = eval(node->call.fn, env);
            if (!fn_val) return make_unit();

            if (fn_val->type != VAL_FUNC) {
                fprintf(stderr, STR_NON_FUN_CALL, node->lineno);
                free_value(fn_val);
                return make_unit();
            }

            /* Evaluate the argument. */
            Value *arg_val = eval(node->call.arg, env);
            if (!arg_val) {
                free_value(fn_val);
                return make_unit();
            }

            /* Create a new environment for the function call, chained to the function's closure environment. */
            Env *local = new_env(fn_val->func->env);
            env_set(local, fn_val->func->param, arg_val, false);

            /* Evaluate the function body in this new environment. */
            Value *res = eval(fn_val->func->body, local);


            /* arg_val is now owned by the local environment and freed by free_env. */
//            env_release(local);
            return res;
        }

        case NODE_SEQ: {
            Value *last = make_unit();
            /* Evaluate each expression in the sequence. */
            for (ExprList *it = node->seq.elist; it; it = it->next) {
                free_value(last); /* Free result of the previous expression. */
                last = eval(it->expr, env);
                if (!last) last = make_unit(); /* Ensure 'last' is never NULL. */
            }
            /* The value of the sequence is the value of the last expression. */
            return last;
        }

        default:
            fprintf(stderr, STR_ERR_UNKNOWN_AST_TYPE, node->lineno);
            return make_unit();
    }
}

/**
 * @brief Helper function to evaluate binary operations.
 *
 * It handles type checking, promotion (int to float), and performing the
 * actual operation for numeric, boolean, and string types.
 *
 * @param node The NODE_BINOP AST node.
 * @param env The current environment.
 * @param l The evaluated left-hand side value.
 * @param r The evaluated right-hand side value.
 * @return A new Value holding the result of the operation.
 */
Value *eval_binop(ASTNode *node, Env *env, Value *l, Value *r)
{
    if (!l || !r) {
        fprintf(stderr, STR_BIN_OP_TYPE_ERR, node->lineno);
        return make_unit();
    }

    /* Check operand types. */
    bool left_is_number = l->type == VAL_INT || l->type == VAL_FLOAT;
    bool right_is_number = r->type == VAL_INT || r->type == VAL_FLOAT;
    bool lr_is_string = l->type == VAL_STRING && r->type == VAL_STRING;

    /* --- String Concatenation --- */
    if (node->binop.op == T_PLUS && lr_is_string) {
        size_t len_l = strlen(l->sval);
        size_t len_r = strlen(r->sval);
        char* new_s = malloc(len_l + len_r + 1);
        if (!new_s) {
            fprintf(stderr, STR_ERR_MALLOC_CONC);
            exit(EXIT_FAILURE);
        }
        memcpy(new_s, l->sval, len_l);
        memcpy(new_s + len_l, r->sval, len_r + 1);
        Value *result = make_string(new_s);
        free(new_s);
        return result;
    }

    /* --- Numeric Operations --- */
    else if (left_is_number && right_is_number) {
        /* Promote to float if either operand is a float. */
        bool is_float = l->type == VAL_FLOAT || r->type == VAL_FLOAT;
        double lf = (l->type == VAL_FLOAT) ? l->fval : (double)l->ival;
        double rf = (r->type == VAL_FLOAT) ? r->fval : (double)r->ival;

        switch (node->binop.op) {
            case T_PLUS:     return is_float ? make_float(lf + rf) : make_int((int)(lf + rf));
            case T_MINUS:    return is_float ? make_float(lf - rf) : make_int((int)(lf - rf));
            case T_MULTIPLY: return is_float ? make_float(lf * rf) : make_int((int)(lf * rf));
            case T_DIVIDE:
                if (rf == 0.0) {
                    fprintf(stderr, STR_ERR_DIV_ZERO, node->lineno);
                    return make_unit();
                }
                /* Division of two ints might produce a float, so we always promote. */
                if (!is_float && (l->ival % r->ival != 0)) {
                    return make_float(lf / rf);
                }
                return is_float ? make_float(lf / rf) : make_int((int)(lf / rf));
            case T_MOD:
                if (rf == 0.0) {
                    fprintf(stderr, STR_ERR_MOD_ZERO, node->lineno);
                    return make_unit();
                }
                /* Modulo is defined for integers. */
                return make_int((int)lf % (int)rf);
            case T_EQ:  return make_bool(lf == rf);
            case T_NEQ: return make_bool(lf != rf);
            case T_LT:  return make_bool(lf < rf);
            case T_GT:  return make_bool(lf > rf);
            case T_LTE: return make_bool(lf <= rf);
            case T_GTE: return make_bool(lf >= rf);
        }
    }

    /* --- Boolean Operations --- */
    else if (l->type == VAL_BOOL && r->type == VAL_BOOL) {
        switch(node->binop.op) {
            case T_AND: return make_bool(l->bval && r->bval);
            case T_OR:  return make_bool(l->bval || r->bval);
            case T_EQ:  return make_bool(l->bval == r->bval);
            case T_NEQ: return make_bool(l->bval != r->bval);
        }
    }

    /* If none of the above conditions matched, it's a type error. */
    fprintf(stderr, STR_BIN_OP_TYPE_ERR, node->lineno);
    return make_unit();
}


/*
 * ----------------------------------------------------------------------------
 * MEMORY MANAGEMENT
 * ----------------------------------------------------------------------------
 */

/**
 * @brief Frees a Value struct and any heap-allocated data it contains.
 * @param v The Value to free.
 */
void free_value(Value *v) {
    if (!v) return;

    switch (v->type) {
        case VAL_STRING:
            free(v->sval);
            break;
        case VAL_FUNC:
            if (v->func) {
                free(v->func->param);
                free(v->func->param_type);
                free(v->func->ret_type);
                /* The function's body (ASTNode) and environment are owned by other *
                 * parts of the program (AST or parent environments) and are not    *
                 * freed here to prevent double-freeing.                            */
                free(v->func);
            }
            break;
        default:
            /* Other types (INT, FLOAT, BOOL, UNIT) don't have nested allocations. */
            break;
    }
    free(v);
}

/**
 * @brief Recursively frees an entire Abstract Syntax Tree.
 * @param node The root of the AST (or sub-tree) to free.
 */
void free_ast(ASTNode *node) {
    if (!node) return;

    switch(node->type) {
        case NODE_VAL:
            free_value(node->val);
            break;
        case NODE_VAR:
            free(node->var);
            break;
        case NODE_UNOP:
            free_ast(node->unop.operand);
            break;
        case NODE_BINOP:
            free_ast(node->binop.left);
            free_ast(node->binop.right);
            break;
        case NODE_IF:
            free_ast(node->ifexpr.cond);
            free_ast(node->ifexpr.then_expr);
            free_ast(node->ifexpr.else_expr);
            break;
        case NODE_LET:
            free(node->let.name);
            free_ast(node->let.value);
            free_ast(node->let.body);
            break;
        case NODE_ASSIGN:
            free(node->assign.name);
            free_ast(node->assign.value);
            break;
        case NODE_CONST:
            free(node->cdef.name);
            free(node->cdef.type_name);
            free_ast(node->cdef.value);
            break;
        case NODE_LAMBDA:
            free(node->lambda.param);
            free(node->lambda.param_type);
            free(node->lambda.ret_type);
            /* The lambda body's ownership is transferred to the Function struct
             * when it is evaluated. The AST of the body is freed when the
             * function object is eventually garbage collected or the program ends.
             * So we DO NOT free it here. free_ast(node->lambda.body); */
            break;
        case NODE_CALL:
            free_ast(node->call.fn);
            free_ast(node->call.arg);
            break;
        case NODE_SEQ: {
            ExprList *curr = node->seq.elist;
            while (curr) {
                ExprList *next = curr->next;
                free_ast(curr->expr);
                free(curr);
                curr = next;
            }
            break;
        }
        default:
            break;
    }
    free(node);
}

/*
 * ----------------------------------------------------------------------------
 * MAIN PROGRAM AND ERROR HANDLING
 * ----------------------------------------------------------------------------
 */

/**
 * @brief The main entry point for the interpreter.
 *
 * Sets up the global environment and runs the parser in a loop, either
 * from a file or from standard input (REPL mode).
 */
int main(int argc, char **argv)
{
    global_env = new_env(NULL); /* Initialize the global scope. */

    /* File processing mode */
    if (argc > 1) {
        char* filename = argv[1];
        FILE* file_ptr = fopen(filename, "r");

        if (file_ptr == NULL) {
            printf(STR_FILE_LOAD_ERROR, filename);
            return 1;
        }
        yyin = file_ptr; /* Point the lexer to the file. */
        do {
            yyparse();
        } while (!feof(yyin));
        fclose(file_ptr);
    }
    /* Interactive REPL mode */
    else {
        printf(BANNER);
        yyin = stdin; /* Point the lexer to standard input. */
        do {
            fflush(stdout);
            yyparse();
        } while (!feof(yyin));
    }

    /* Cleanup */
    free_env(global_env, true);
    yylex_destroy();
    return 0;
}

/**
 * @brief Error reporting function called by Bison on a parse error.
 * @param s The error message string from Bison.
 */
void yyerror(const char* s) {
    fprintf(stderr, STR_PARSE_ERR, yylineno, s);
}
