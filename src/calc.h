/**
 * @file calc.h
 * @brief Header file defining the core data structures for the calculator/interpreter.
 *
 * This file contains the definitions for the Abstract Syntax Tree (AST),
 * runtime values, environments for variable bindings, and other essential
 * structures used by both the parser (calc.y) and the lexer (calc.l).
 */

/**************************************************************************\
 *                                                                        *
 *  This program is free software: you can redistribute it and/or modify  *
 *  it under the terms of the GNU General Public License as published by  *
 *  the Free Software Foundation, version 3.                              *
 *                                                                        *
 *  This program is distributed in the hope that it will be useful, but   *
 *  WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU      *
 *  General Public License for more details.                              *
 *                                                                        *
 *  You should have received a copy of the GNU General Public License     *
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.  *
 *                                                                        *
\**************************************************************************/

/* Standard header guard to prevent multiple inclusions. */
#ifndef CALC_H
#define CALC_H

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include "env.h"

/* Forward Declarations */

/* These declarations inform the compiler about the existence of these types
 * without needing their full definition yet. This is crucial for breaking
 * circular dependencies (e.g., ASTNode can contain a Value, and a Value
 * can contain a Function which points to an ASTNode). */
struct ExprList;
struct ASTNode;
struct Env;
struct Value;

typedef struct ExprList ExprList;
typedef struct ASTNode ASTNode;
typedef struct Env Env;
typedef struct Value Value;

/* External Declarations from Flex/Bison -- These are global variables and
 * functions generated by or used by Flex and Bison. */

extern int yylex();          /* The lexer function generated by Flex. */
extern int yylineno;          /* The current line number, maintained by Flex. */
extern FILE* yyin;           /* The input stream for the lexer. */
void yyerror(const char* s); /* The error reporting function for the parser. */

/* Function Prototypes for Memory Management */

void free_value(Value *v);
void free_ast(ASTNode *node);


/*
 * ============================================================================
 * Runtime Value Representation
 * ============================================================================
 */

/**
 * @brief Enumerates the types of values that can exist at runtime.
 */
typedef enum {
    VAL_INT,
    VAL_FLOAT,
    VAL_BOOL,
    VAL_STRING,
    VAL_FUNC,   /* A function closure */
    VAL_UNIT    /* A special type representing "no value", like void. */
} ValType;

/**
 * @brief Represents a function closure.
 *
 * This struct holds all information needed to execute a function, including
 * its parameter, body, and the environment in which it was defined (the closure).
 */
typedef struct Function {
    char *param;        /* Name of the single parameter. */
    char *param_type;   /* (Optional) Name of the parameter's type. */
    char *ret_type;     /* (Optional) Name of the function's return type. */
    ASTNode *body;      /* Pointer to the AST of the function's body. */
    Env *env;           /* Pointer to the environment where the function was created. This is the "closure". */
} Function;

/**
 * @brief Represents any runtime value in the language.
 *
 * This is a tagged union. The `type` field determines which member of the
 * union is active.
 */
struct Value {
    ValType type;
    union {
        int ival;         /* For VAL_INT */
        double fval;      /* For VAL_FLOAT */
        bool bval;        /* For VAL_BOOL */
        char *sval;       /* For VAL_STRING (heap-allocated) */
        Function *func;   /* For VAL_FUNC (heap-allocated) */
    };
};


/**
 * @brief Represents an environment (or scope).
 *
 * Environments are chained together via the `parent` pointer to create nested
 * scopes, enabling lexical scoping.
 */

struct Env {
    struct Binding *bindings;  /* A linked list of bindings in this scope. */
    struct Env *parent;        /* A pointer to the enclosing (parent) scope. */
    int ref_count;
};

/*
 * ============================================================================
 * Abstract Syntax Tree (AST)
 * ============================================================================
 */

/**
 * @brief A node in a linked list of expressions.
 * Used for `do...end` blocks or other sequences.
 */
struct ExprList {
    ASTNode *expr;
    struct ExprList *next;
};

/**
 * @brief Enumerates the different types of nodes in the AST.
 * Each type corresponds to a specific language construct.
 */
typedef enum {
    NODE_VAL,     /* A literal value (e.g., 5, "hello", true) */
    NODE_VAR,     /* A variable identifier (e.g., x) */
    NODE_UNOP,    /* A unary operation (e.g., -x, not b) */
    NODE_BINOP,   /* A binary operation (e.g., x + y) */
    NODE_IF,      /* An if-then-else expression */
    NODE_CALL,    /* A function call */
    NODE_LAMBDA,  /* A function definition (anonymous) */
    NODE_LET,     /* A let-in binding expression */
    NODE_ASSIGN,  /* A variable assignment */
    NODE_CONST,   /* A constant definition */
    NODE_SEQ      /* A sequence of expressions */
} NodeType;

/**
 * @brief Represents a node in the Abstract Syntax Tree.
 *
 * This is the primary data structure for representing parsed code before
 * it is evaluated. It is a tagged union where `type` determines which
 * part of the union is active.
 */
struct ASTNode {
    NodeType type;
    int lineno; /* The line number where this node's construct begins, for error reporting. */
    union {
        /* For NODE_VAL: A literal value. */
        Value *val;

        /* For NODE_VAR: The name of the variable. */
        char *var;

        /* For NODE_BINOP: A binary operation. */
        struct { ASTNode *left, *right; int op; } binop;

        /* For NODE_UNOP: A unary operation. */
        struct { ASTNode *operand; int op; } unop;

        /* For NODE_IF: An if-then-else expression. */
        struct { ASTNode *cond, *then_expr, *else_expr; } ifexpr;

        /* For NODE_LAMBDA: A function definition. */
        struct { char *param, *param_type, *ret_type; ASTNode *body; } lambda;

        /* For NODE_CALL: A function application. */
        struct { ASTNode *fn; ASTNode *arg; } call;

        /* For NODE_LET: A local binding. */
        struct { char *name; ASTNode *value; ASTNode *body; } let;

        /* For NODE_ASSIGN: A variable assignment. */
        struct { char *name; ASTNode *value; } assign;

        /* For NODE_CONST: A constant definition. */
        struct { char *name; char *type_name; ASTNode *value; } cdef;

        /* For NODE_SEQ: A sequence of expressions. */
        struct { ExprList *elist; } seq;
    };
};

/* --- AST and Value Constructor Prototypes --- */
Value *eval(ASTNode *node, Env *env);
Value *make_int(int x);
Value *make_float(double x);
Value *make_bool(bool b);
Value *make_string(const char *s);
Value *make_func(Function *f);
Value *make_unit();
ASTNode *make_node(NodeType t);


/*
 * ============================================================================
 * Inline Helper Functions
 * ============================================================================
 */

/**
 * @brief Safely duplicates a string. Returns NULL if the input is NULL.
 * @param s The string to duplicate.
 * @return A new, heap-allocated copy of the string.
 */
static inline char *dupstr(const char *s) {
    return s ? strdup(s) : NULL;
}

/**
 * @brief Creates a duplicate of a Value.
 *
 * This function performs a deep copy for heap-allocated data within the Value,
 * such as strings. For functions, it creates a new Function struct but shares
 * pointers to the AST body and closure environment, as these should not be
 * duplicated. The caller is responsible for freeing the returned Value.
 *
 * @param v The Value to duplicate.
 * @return A new, heap-allocated copy of the Value.
 */
static inline Value *dup_value(const Value *v) {
    if (!v) return NULL;
    Value *nv = malloc(sizeof(Value));
    if (!nv) {
        fprintf(stderr, "Fatal: malloc failed in dup_value\n");
        exit(EXIT_FAILURE);
    }
    nv->type = v->type;
    switch (v->type) {
        case VAL_INT:   nv->ival = v->ival; break;
        case VAL_FLOAT: nv->fval = v->fval; break;
        case VAL_BOOL:  nv->bval = v->bval; break;
        case VAL_STRING:
            /* Deep copy the string. */
            nv->sval = dupstr(v->sval);
            break;
        case VAL_FUNC: {
            /* "Shallow" copy the function. We duplicate the container and its
             * strings, but share pointers to the AST and environment.   */
            Function *of = v->func;
            Function *nf = malloc(sizeof(Function));
            if (!nf) {
                fprintf(stderr, "Fatal: malloc failed in dup_value(VAL_FUNC)\n");
                exit(EXIT_FAILURE);
            }
            nf->param = dupstr(of->param);
            nf->param_type = dupstr(of->param_type);
            nf->ret_type = dupstr(of->ret_type);

            nf->body = of->body; /* Share the pointer to the AST body. */
            nf->env = of->env;   /* Share the pointer to the closure environment. */

        env_retain(nf->env);

            nv->func = nf;
            break;
        }
        case VAL_UNIT:
        default:
            /* Nothing extra to copy for UNIT or other types. */
            break;
    }
    return nv;
}

#endif // CALC_H
