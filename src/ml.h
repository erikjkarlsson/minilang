/**
 * @file calc.h
 * Header file defining the core data structures for the calculator/interpreter.
 *
 * This file contains the definitions for the Abstract Syntax Tree (AST),
 * runtime values, environments for variable bindings, and other essential
 * structures used by both the parser (calc.y) and the lexer (calc.l).
 */

/**************************************************************************\
 *                                                                        *
 *  This program is free software: you can redistribute it and/or modify  *
 *  it under the terms of the GNU General Public License as published by  *
 *  the Free Software Foundation, version 3.                              *
 *                                                                        *
 *  This program is distributed in the hope that it will be useful, but   *
 *  WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU      *
 *  General Public License for more details.                              *
 *                                                                        *
 *  You should have received a copy of the GNU General Public License     *
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.  *
 *                                                                        *
\**************************************************************************/

/* Standard header guard to prevent multiple inclusions. */

#ifndef ML_H
#define ML_H
#define DEBUG 1
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <signal.h>

#include "env.h"
#include "trace_stack.h"

/* Display strings for different value types. */
#define STR_SHOW_TRUE   "true"
#define STR_SHOW_FALSE  "false"
#define STR_SHOW_INT    "=> %d\n"
#define STR_SHOW_FLOAT  "=> %.6g\n"
#define STR_SHOW_BOOL   "=> %s\n"
#define STR_SHOW_STRING "=> \"%s\"\n"
#define STR_SHOW_FUNC   "=> <function>\n"
#define STR_SHOW_UNIT   "\n" /* Unit type prints nothing. */

/* Error message strings. */
#define STR_ERR_NON_BOOL_NOT      "Line %d: Error: NOT requires a boolean operand\n"
#define STR_ERR_IF_NON_BOOL       "Line %d: Error: IF condition must be a boolean\n"
#define STR_NON_FUN_CALL          "Line %d: Error: Attempted to call a non-function value\n"
#define STR_BIN_OP_TYPE_ERR       "Line %d: Error: Type mismatch in binary operation\n"
#define STR_ERR_UNKNOWN_AST_TYPE  "Line %d: Error: Unknown AST node type\n"
#define STR_ERR_MALLOC_CONC       "Fatal: malloc failed in string concat\n"
#define STR_ERR_DIV_ZERO          "Line %d: Error: Division by zero\n"
#define STR_ERR_MOD_ZERO          "Line %d: Error: Modulo by zero\n"
#define STR_UNARY_MINUS           "Line %d: Error: Unary minus requires a numeric operand\n"
#define STR_CALLOC_FAIL           "Line %d: Fatal, calloc failed in make_node\n"
#define STR_PARSE_ERR             "Line %d: Parse error: %s\n"

/* General strings. */
#define STR_GOODBYE             "Goodbye!\n"
#define STR_FILE_LOAD_ERROR     "Error loading file %s"
#define BANNER                  "Type 'quit' or 'exit' to leave.\n\n"


#define str(val) #val

#ifdef DEBUG
#define DEBUG_TEST 1
#else
#define DEBUG_TEST 0
#endif

#define DBG(fmt, ...)                                                          \
  do {                                                                         \
    if (DEBUG)                                                                 \
      fprintf(stderr, "<%s:%d> %s()\t : " fmt, __FILE__, __LINE__, __func__,        \
              __VA_ARGS__);                                                    \
  } while (0)

// Ex: DBG("%s", "hello")

#define LOG(...)                                                               \
  do {                                                                         \
    if (DEBUG)                                                                 \
      fprintf(stderr, "<%s:%d>%s()\t : %s\n", __FILE__, __LINE__, __func__,        \
              __VA_ARGS__);                                             \
  } while (0)

struct ExprList;
struct ASTNode;
struct Env;
struct Value;

typedef struct ExprList ExprList;
typedef struct ASTNode ASTNode;
typedef struct Env Env;
typedef struct Value Value;

static inline void display_value(Value *v);
static inline void print_value(Value* v, char* buf, size_t buf_size);
char* print_node(ASTNode* node);

/* These are global variables and functions generated by or used by Flex and
 * Bison. */

/** The lexer function generated by Flex. */
extern int yylex();

/** The current line number, maintained by Flex. */
extern int yylineno;

/** The input stream for the lexer. */
extern FILE *yyin;
#define DBGBUF_SIZE 256
static char dbgbuf[DBGBUF_SIZE];
/** The error reporting function for the parser. */
void yyerror(const char* s);

/* Forward declarations of helper functions defined in the C section below. */

static trace_stack_t g_trace_stack;
static inline void setup_trace()
{
    trace_stack_init(&g_trace_stack);
    trace_stack_install_signal_handlers(&g_trace_stack);
}


#define MAX_DEPTH 16
#define TRACE(stack) trace_stack_log(stack, __func__, __FILE__, __LINE__)
#define SET_TRACE_POS(stack, pos) trace_stack_pos(stack, __func__, pos)
#define BACKTRACE(stack) trace_stack_dump(stack, stderr)
#define TRACE_RETURN(val) do { return val; } while(true)

/* Destructors */

static inline void free_value(Value *v);
static inline void free_ast(ASTNode *node);

/*
 * Runtime Value Representation
 *
 */

/**
 * Enumerates the types of values that can exist at runtime.
 */

typedef enum {
    VAL_INT,    /**< Integer value */
    VAL_FLOAT,  /**< Floating point value */
    VAL_BOOL,   /**< Boolean value */
    VAL_STRING, /**< String value */
    VAL_FUNC,   /**< A function closure */
    VAL_UNIT    /**< A special type representing "no value", like void. */
} ValType;


static inline const char *value_name(ValType v)
{
    switch (v) {
    case VAL_INT:    return "integer";
    case VAL_FLOAT:  return "float";
    case VAL_BOOL:   return "boolean";
    case VAL_STRING: return "string";
    case VAL_FUNC:   return "function";
    case VAL_UNIT:   return "unit";
    default:         return "invalid";
    }
}




/**
 * Represents a function closure.
 *
 * This struct holds all information needed to execute a function, including
 * its parameter, body, and the environment in which it was defined (the closure).
 */
typedef struct Function {
    char *param;        /**< Name of the single parameter. */
    char *param_type;   /**< (Optional) Name of the parameter's type. */
    char *ret_type;     /**< (Optional) Name of the function's return type. */
    ASTNode *body;      /**< Pointer to the AST of the function's body. */
    Env *env;           /**< Pointer to the environment at function creation "closure". */
} Function;

/**
 * Represents any runtime value in the language.
 *
 * This is a tagged union. The `type` field determines which member of the
 * union is active.
 */
struct Value {
    ValType type;
    union {
        int ival;         /**< For VAL_INT */
        double fval;      /**< For VAL_FLOAT */
        bool bval;        /**< For VAL_BOOL */
        char *sval;       /**< For VAL_STRING (heap-allocated) */
        Function *func;   /**< For VAL_FUNC (heap-allocated) */
    };
};


/**
 * Represents an environment (or scope).
 *
 * Environments are chained together via the `parent` pointer to create nested
 * scopes, enabling lexical scoping.
 */

struct Env {
    struct Binding *bindings;  /**< A linked list of bindings in this scope. */
    struct Env *parent;        /**< A pointer to the enclosing (parent) scope. */

    int ref_count; /**< Environment reference counter, environment is free'd
                        when this =0 */
};

/*
 * Abstract Syntax Tree
 */

/**
 * A node in a linked list of expressions.
 *
 * Used for `do...end` blocks or other sequences.
 */
struct ExprList {
    ASTNode *expr;
    struct ExprList *next;
};

/**
 * Enumerates the different types of nodes in the AST.
 *
 * Each type corresponds to a specific language construct.
 */
typedef enum {
    NODE_VAL,     /**< A literal value (e.g., 5, "hello", true) */
    NODE_VAR,     /**< A variable identifier (e.g., x) */
    NODE_UNOP,    /**< A unary operation (e.g., -x, not b) */
    NODE_BINOP,   /**< A binary operation (e.g., x + y) */
    NODE_IF,      /**< An if-then-else expression */
    NODE_CALL,    /**< A function call */
    NODE_LAMBDA,  /**< A function definition (anonymous) */
    NODE_LET,     /**< A let-in binding expression */
    NODE_ASSIGN,  /**< A variable assignment */
    NODE_CONST,   /**< A constant definition */
    NODE_MVAR,    /**< A mutable variable definition */
    NODE_SEQ      /**< A sequence of expressions */
} NodeType;

/**
 * Represents a node in the Abstract Syntax Tree.
 *
 * This is the primary data structure for representing parsed code before
 * it is evaluated. It is a tagged union where `type` determines which
 * part of the union is active.
 */
struct ASTNode {
    NodeType type;
    int lineno; /* The line number where this node's construct begins, for error reporting. */
    union {
        /** For NODE_VAL: A literal value. */
        Value *val;

        /** For NODE_VAR: The name of the variable. */
        char *var;

        /** For NODE_BINOP: A binary operation. */
        struct { ASTNode *left, *right; int op; } binop;

        /** For NODE_UNOP: A unary operation. */
        struct { ASTNode *operand; int op; } unop;

        /** For NODE_IF: An if-then-else expression. */
        struct { ASTNode *cond, *then_expr, *else_expr; } ifexpr;

        /** For NODE_LAMBDA: A function definition. */
        struct { char *param, *param_type, *ret_type; ASTNode *body; } lambda;

        /** For NODE_CALL: A function application. */
        struct { ASTNode *fn; ASTNode *arg; } call;

        /** For NODE_LET: A local binding. */
        struct { char *name; ASTNode *value; ASTNode *body; } let;

        /** For NODE_ASSIGN: A variable assignment. */
        struct { char *name; ASTNode *value; } assign;

        /** For NODE_CONST: A constant definition. */
        struct { char *name; char *type_name; ASTNode *value; } cdef;

        /** For NODE_CONST: A constant definition. */
        struct { char *name; char *type_name; ASTNode *value; } vdef;

        /** For NODE_SEQ: A sequence of expressions. */
        struct { ExprList *elist; } seq;
    };
};



/*
 * ============================================================================
 * Inline Helper Functions
 * ============================================================================
 */

/**
 * Safely duplicates a string. Returns NULL if the input is NULL.
 *
 * @param s The string to duplicate.
 * @return A new, heap-allocated copy of the string.
 */
static inline char *dupstr(const char *s) {
    return s ? strdup(s) : NULL;
}

/**
 * Creates a duplicate of a Value.
 *
 * This function performs a deep copy for heap-allocated data within the Value,
 * such as strings. For functions, it creates a new Function struct but shares
 * pointers to the AST body and closure environment, as these should not be
 * duplicated. The caller is responsible for freeing the returned Value.
 *
 * @param v The Value to duplicate.
 * @return A new, heap-allocated copy of the Value.
 */
static inline Value *dup_value(const Value *v) {
  if (!v)
    return NULL;

    Value *nv = malloc(sizeof(Value));
    if (!nv) {
        fprintf(stderr, "Fatal: malloc failed in dup_value\n");
        exit(EXIT_FAILURE);
    }
    nv->type = v->type;

    switch (v->type) {
        case VAL_INT:   nv->ival = v->ival; break;
        case VAL_FLOAT: nv->fval = v->fval; break;
        case VAL_BOOL:  nv->bval = v->bval; break;
        case VAL_STRING:
            /* Deep copy the string. */
            nv->sval = dupstr(v->sval);
            break;
        case VAL_FUNC: {
            /* "Shallow" copy the function. We duplicate the container and its
             * strings, but share pointers to the AST and environment.   */
            Function *of = v->func;
            Function *nf = malloc(sizeof(Function));
            if (!nf) {
                fprintf(stderr, "Fatal: malloc failed in dup_value(VAL_FUNC)\n");
                exit(EXIT_FAILURE);
            }
            nf->param = dupstr(of->param);
            nf->param_type = dupstr(of->param_type);
            nf->ret_type = dupstr(of->ret_type);

            nf->body = of->body; /* Share the pointer to the AST body. */
            nf->env = of->env;   /* Share the pointer to the closure environment. */

        env_retain(nf->env);

            nv->func = nf;
            break;
        }
        case VAL_UNIT:
        default:
            /* Nothing extra to copy for UNIT or other types. */
            break;
    }
    return nv;
}



/*
 * ----------------------------------------------------------------------------
 * HELPER FUNCTIONS
 * ----------------------------------------------------------------------------
 */

/**
 * Creates a new ASTNode of a given type.
 *
 * @param t The NodeType for the new node.
 * @return A pointer to the newly allocated and initialized ASTNode.
 */

static inline ASTNode *make_node(NodeType t)
{
    ASTNode *n = calloc(1, sizeof(ASTNode));
    if (!n) {
        fprintf(stderr, STR_CALLOC_FAIL, yylineno);
        exit(EXIT_FAILURE);
    }
    n->type = t;
    n->lineno = yylineno; // Store the line number for error reporting.
    return n;
}


/*
 * ----------------------------------------------------------------------------
 * VALUE CONSTRUCTORS
 * ----------------------------------------------------------------------------
 * These functions create `Value` structs for the interpreter. They handle
 * memory allocation and initialization for different data types.
 */

/**
 * Create a integer value
 */
static inline Value *make_int(int x)
{
  TRACE(&g_trace_stack);
  Value *v = (Value*)malloc(sizeof(Value));
    v->type = VAL_INT;
    v->ival = x;
    return v;
}

/**
 * Create a floating point value
 */
static inline Value *make_float(double x)
{
  TRACE(&g_trace_stack);
  Value *v =(Value*)malloc(sizeof(Value));
    v->type = VAL_FLOAT;
    v->fval = x;
    return v;
}

/**
 * Create a boolean value
 */
static inline Value *make_bool(bool b)
{
  TRACE(&g_trace_stack);
  Value *v = (Value*)malloc(sizeof(Value));
    v->type = VAL_BOOL;
    v->bval = b;
    return v;
}

/**
 * Create a empty (unit) value
 */
static inline Value *make_unit()
{
  TRACE(&g_trace_stack);
  Value *v = (Value*)malloc(sizeof(Value));
    v->type = VAL_UNIT;
    return v;
}

/**
 * Create a string value
 */
static inline Value *make_string(const char *s)
 {
  TRACE(&g_trace_stack);
  Value *v = (Value*)malloc(sizeof(Value));
    v->type = VAL_STRING;
    v->sval = strdup(s); /* Use strdup for safety. */
    return v;
}

/**
 * Create a function value
 */
static inline Value *make_func(Function *f)
{
  TRACE(&g_trace_stack);
  Value *v = (Value*)malloc(sizeof(Value));
    v->type = VAL_FUNC;
    v->func = f;
    return v;
}

/**
 * Free a string value.
 */
static inline void free_string_value(Value *v)
{
  if (!v) return;
  if (v->sval) {
      free(v->sval);
      v->sval = NULL;
  }
}

/**
 * Free a function value.
 */
static inline void free_func_value(Value *v)
{
  if (!v)
    return;
  TRACE(&g_trace_stack);
    if (v->func) {
        free(v->func->param);
        free(v->func->param_type);
        free(v->func->ret_type);

        /* The function's body (ASTNode) and environment is owned by the AST or *
         * parent environments) and are thys not (preventing double-free).      */

        free(v->func);
        v->func = NULL;
    }
}

/**
 * Frees a Value struct and any heap-allocated data it contains.
 * @param v The Value to free.
 */
static inline void free_value(Value *v)
{
  TRACE(&g_trace_stack);
  if (!v) {
    TRACE_RETURN();
        }
    switch (v->type) {

    case VAL_STRING:
        free_string_value(v);
        break;

    case VAL_FUNC:
        free_func_value(v);
        break;

    /* Doesn't have any nested allocations. */
    case VAL_INT:
    case VAL_BOOL:
    case VAL_UNIT:
    case VAL_FLOAT:
    default: break;
    }

  free(v);
  v = NULL;
  TRACE_RETURN();
}

/**
 * Recursively frees an entire Abstract Syntax Tree.
 *
 * @param node The root of the AST (or sub-tree) to free.
 */

static inline void free_ast(ASTNode *node)
{
  TRACE(&g_trace_stack);
  if (!node) {
    TRACE_RETURN();
  }

    switch(node->type) {

    case NODE_VAL: /* GENERAL VALUE */
        if (DEBUG) {
            //display_value(node->val);
        }
      free_value(node->val);
      break;

    case NODE_VAR:    /* GENERAL VARIABLE */
      free(node->var);
      break;

    case NODE_UNOP:   /* UNARY OPERATION*/
      free_ast(node->unop.operand);
      break;

    case NODE_BINOP:  /* BINARY OPERATION*/
        free_ast(node->binop.left);
        free_ast(node->binop.right);
        break;

    case NODE_IF:     /* IF-THEN-ELSE */
        free_ast(node->ifexpr.cond);
        free_ast(node->ifexpr.then_expr);
        free_ast(node->ifexpr.else_expr);
        break;

    case NODE_LET:    /* SCOPED VARIABLES  */
        free(node->let.name);
        free_ast(node->let.value);
        free_ast(node->let.body);
        break;

    case NODE_ASSIGN: /* ASSIGNMENT */
        free(node->assign.name);
        free_ast(node->assign.value);
        break;

    case NODE_CONST:  /* IMMUTABLE VARIABLE */
        free(node->cdef.name);
        free(node->cdef.type_name);
        free_ast(node->cdef.value);
        break;

    case NODE_MVAR:   /* MUTABLE VARIABLE */
        free(node->vdef.name);
        free(node->vdef.type_name);
        free_ast(node->vdef.value);
        break;

    case NODE_LAMBDA: /* LAMBDA FUNCTION */
        free(node->lambda.param);
        free(node->lambda.param_type);
        free(node->lambda.ret_type);
        /* The lambda body's ownership is transferred to the Function struct
         * when it is evaluated. The AST of the body is freed when the
         * function AST object eventually is garbage collected or when the
         * program ends. So we DO NOT free it here. */
        break;

    case NODE_CALL: /* FUNCTION APPLICATION */
        free_ast(node->call.fn);
        free_ast(node->call.arg);
        break;

    case NODE_SEQ: { /* EXPRESSION SEQUENCE */
      ExprList *next;
      ExprList *curr;

      curr = node->seq.elist;
      while (curr) {
          next = curr->next;
          free_ast(curr->expr);
          free(curr);
          curr = next;
      }
      break;
    }
    default: break;
    }

    free(node);
    node = NULL;
    TRACE_RETURN();
}


static inline void dbgf(const char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    vfprintf(stderr, fmt, args);
    va_end(args);
}

static inline void print_value(Value* v, char* buf, size_t buf_size) {
    switch (v->type) {
        case VAL_INT:    snprintf(buf, buf_size, "%d\0", v->ival); break;
        case VAL_FLOAT:  snprintf(buf, buf_size, "%.2f\0", v->fval); break;
        case VAL_BOOL:   snprintf(buf, buf_size, "%s\0", v->bval ? "true" : "false"); break;
        case VAL_STRING: snprintf(buf, buf_size, "%.*s\0", (int)buf_size - 1, v->sval); break;
        case VAL_FUNC:
            snprintf(buf, buf_size, "ðº%s.%s\0",
                     v->func->param,
                     print_node(v->func->body));
            break;
        case VAL_UNIT:   snprintf(buf, buf_size, "unit\0"); break;
    }
}
static inline void display_value(Value *v)
{
    print_value(v, dbgbuf, DBGBUF_SIZE);
    printf("%s", dbgbuf);
}
static inline void show_value(const char* fmt, Value *v)
{
    print_value(v, dbgbuf, DBGBUF_SIZE);
    printf(fmt, dbgbuf);
}

// Function to convert an AST node to its code string representation

static inline void display_env(Env *env, int indent)
    {
    if (!env) {
        printf("%*s(ERROR NULL ENV)\n", indent, "");
        return;
    }

    for (int i = 0; i < indent; i++) printf("  ");

    printf("Scope:\n");
    for (Binding* b = env->bindings; b; b = b->next) {
        printf("%*s  %s = ", indent, "", b->name);
        show_value("=> %s ", b->val);
    }

    if (env->parent) {
        printf("%*s  Parent:\n", indent, "");
        display_env(env->parent, indent + 2);
    }
}

#endif // ML_H
